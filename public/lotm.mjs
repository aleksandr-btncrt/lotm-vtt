/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
class LotmActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't 
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    const actorData = this;
    actorData.flags.lotm || {};
  }

  /**
   * 
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic 
   * approach is useful when you have actors & items that share a parent Document, 
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...this.system.getRollData?.() ?? null };
  }

  /**
   * Convert the actor document to a plain object.
   * 
   * The built in `toObject()` method will ignore derived data when using Data Models.
   * This additional method will instead use the spread operator to return a simplified
   * version of the data.
   * 
   * @returns {object} Plain object either via deepClone or the spread operator.
   */
  toPlainObject() {
    const result = {...this};

    console.log("LotmActor.toPlainObject", result);

    // Simplify system data.
    result.system = this.system.toPlainObject();

    // Add items.
    result.items = this.items?.size > 0 ? this.items.contents : [];

    // Add effects.
    result.effects = this.effects?.size > 0 ? this.effects.contents : [];

    return result;
  }

}

/**
 * Extend the basic Item with some very simple modifications.
 * @extends {Item}
 */
let LotmItem$1 = class LotmItem extends Item {
  /**
   * Augment the basic Item data model with additional dynamic data.
   */
  prepareData() {
    // As with the actor class, items are documents that can have their data
    // preparation methods overridden (such as prepareBaseData()).
    super.prepareData();
  }

  /**
   * Prepare a data object which defines the data schema used by dice roll commands against this Item
   * @override
   */
  getRollData() {
    // Starts off by populating the roll data with a shallow copy of `this.system`
    const rollData = { ...this.system };

    // Quit early if there's no parent actor
    if (!this.actor) return rollData;

    // If present, add the actor's roll data
    rollData.actor = this.actor.getRollData();

    return rollData;
  }

  /**
   * Convert the actor document to a plain object.
   *
   * The built in `toObject()` method will ignore derived data when using Data Models.
   * This additional method will instead use the spread operator to return a simplified
   * version of the data.
   *
   * @returns {object} Plain object either via deepClone or the spread operator.
   */
  toPlainObject() {
    const result = { ...this };

    // Simplify system data.
    result.system = this.system.toPlainObject();

    // Add effects.
    result.effects = this.effects?.size > 0 ? this.effects.contents : [];

    return result;
  }

  /**
   * Handle clickable rolls.
   * @param {Event} event   The originating click event
   * @private
   */
  async roll() {
    const item = this;

    // Initialize chat data.
    const speaker = ChatMessage.getSpeaker({ actor: this.actor });
    const rollMode = game.settings.get('core', 'rollMode');
    const label = `[${item.type}] ${item.name}`;

    // If there's no roll data, send a chat message.
    if (!this.system.formula) {
      ChatMessage.create({
        speaker: speaker,
        rollMode: rollMode,
        flavor: label,
        content: item.system.description ?? '',
      });
    }
    // Otherwise, create a roll and send a chat message from it.
    else {
      // Retrieve roll data.
      const rollData = this.getRollData();

      // Invoke the roll and submit it to chat.
      const roll = new Roll(rollData.formula, rollData.actor);
      // If you need to store the value first, uncomment the next line.
      // const result = await roll.evaluate();
      roll.toMessage({
        speaker: speaker,
        rollMode: rollMode,
        flavor: label,
      });
      return roll;
    }
  }
};

/**
 * Manage Active Effect instances through an Actor or Item Sheet via effect control buttons.
 * @param {MouseEvent} event      The left-click event on the effect control
 * @param {Actor|Item} owner      The owning document which manages this effect
 */
function onManageActiveEffect(event, owner) {
  event.preventDefault();
  const a = event.currentTarget;
  const li = a.closest('li');
  const effect = li.dataset.effectId
    ? owner.effects.get(li.dataset.effectId)
    : null;
  switch (a.dataset.action) {
    case 'create':
      return owner.createEmbeddedDocuments('ActiveEffect', [
        {
          name: game.i18n.format('DOCUMENT.New', {
            type: game.i18n.localize('DOCUMENT.ActiveEffect'),
          }),
          icon: 'icons/svg/aura.svg',
          origin: owner.uuid,
          'duration.rounds':
            li.dataset.effectType === 'temporary' ? 1 : undefined,
          disabled: li.dataset.effectType === 'inactive',
        },
      ]);
    case 'edit':
      return effect.sheet.render(true);
    case 'delete':
      return effect.delete();
    case 'toggle':
      return effect.update({ disabled: !effect.disabled });
  }
}

/**
 * Prepare the data structure for Active Effects which are currently embedded in an Actor or Item.
 * @param {ActiveEffect[]} effects    A collection or generator of Active Effect documents to prepare sheet data for
 * @return {object}                   Data for rendering
 */
function prepareActiveEffectCategories(effects) {
  // Define effect header categories
  const categories = {
    temporary: {
      type: 'temporary',
      label: game.i18n.localize('LOTM.Effect.Temporary'),
      effects: [],
    },
    passive: {
      type: 'passive',
      label: game.i18n.localize('LOTM.Effect.Passive'),
      effects: [],
    },
    inactive: {
      type: 'inactive',
      label: game.i18n.localize('LOTM.Effect.Inactive'),
      effects: [],
    },
  };

  // Iterate over active effects, classifying them into categories
  for (let e of effects) {
    if (e.disabled) categories.inactive.effects.push(e);
    else if (e.isTemporary) categories.temporary.effects.push(e);
    else categories.passive.effects.push(e);
  }
  return categories;
}

const ActorSheet$1 = foundry.appv1.sheets.ActorSheet;

/**
 * Extend the basic ActorSheet with some very simple modifications
 * @extends {ActorSheet}
 */
class LotmActorSheet extends ActorSheet$1 {
  /** @override */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ['lotm', 'sheet', 'actor'],
      width: 600,
      height: 600,
      tabs: [
        {
          navSelector: '.sheet-tabs',
          contentSelector: '.sheet-body',
          initial: 'character',
        },
      ],
    });
  }

  /** @override */
  get template() {
    return `systems/lotm/templates/actor/actor-${this.actor.type}-sheet.hbs`;
  }

  /* -------------------------------------------- */

  /** @override */
  async getData() {
    // Retrieve the data structure from the base sheet. You can inspect or log
    // the context variable to see the structure, but some key properties for
    // sheets are the actor object, the data object, whether or not it's
    // editable, the items array, and the effects array.
    const context = super.getData();
    console.log("context", context);

    // Use a safe clone of the actor data for further operations.
    const actorData = this.document.toPlainObject();
    // Add the actor's data to context.data for easier access, as well as flags.
    context.system = actorData.system;
    console.log("ActorData", actorData);
    context.flags = actorData.flags;

    // Adding a pointer to CONFIG.LOTM
    context.config = CONFIG.LOTM;

    // Prepare character data and items.
    if (actorData.type == 'character') {
      this._prepareItems(context);
      this._prepareCharacterData(context);
    }

    // Prepare NPC data and items.
    if (actorData.type == 'npc') {
      this._prepareItems(context);
    }

    // Enrich biography info for display
    // Enrichment turns text like `[[/r 1d20]]` into buttons
    context.enrichedBiography = await foundry.applications.ux.TextEditor.implementation.enrichHTML(
      this.actor.system.biography,
      {
        // Whether to show secret blocks in the finished html
        secrets: this.document.isOwner,
        // Data to fill in for inline rolls
        rollData: this.actor.getRollData(),
        // Relative UUID resolution
        relativeTo: this.actor,
      }
    );

    // Prepare active effects
    context.effects = prepareActiveEffectCategories(
      // A generator that returns all effects stored on the actor
      // as well as any items
      this.actor.allApplicableEffects()
    );

    return context;
  }

  /**
   * Character-specific context modifications
   *
   * @param {object} context The context object to mutate
   */
  _prepareCharacterData(context) {
    // This is where you can enrich character-specific editor fields
    // or setup anything else that's specific to this type
    console.log("_prepareCharacterData", context);
  }

  /**
   * Organize and classify Items for Actor sheets.
   *
   * @param {object} context The context object to mutate
   */
  _prepareItems(context) {
    // Initialize containers.
    const gear = [];
    const features = [];
    const spells = {
      0: [],
      1: [],
      2: [],
      3: [],
      4: [],
      5: [],
      6: [],
      7: [],
      8: [],
      9: [],
    };

    // Iterate through items, allocating to containers
    for (let i of context.items) {
      i.img = i.img || Item.DEFAULT_ICON;
      // Append to gear.
      if (i.type === 'item') {
        gear.push(i);
      }
      // Append to features.
      else if (i.type === 'feature') {
        features.push(i);
      }
      // Append to spells.
      else if (i.type === 'spell') {
        if (i.system.spellLevel != undefined) {
          spells[i.system.spellLevel].push(i);
        }
      }
    }

    // Assign and return
    context.gear = gear;
    context.features = features;
    context.spells = spells;
  }

  /* -------------------------------------------- */

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    // Render the item sheet for viewing/editing prior to the editable check.
    html.on('click', '.item-edit', (ev) => {
      const li = $(ev.currentTarget).parents('.item');
      const item = this.actor.items.get(li.data('itemId'));
      item.sheet.render(true);
    });

    // -------------------------------------------------------------
    // Everything below here is only needed if the sheet is editable
    if (!this.isEditable) return;

    // Add Inventory Item
    html.on('click', '.item-create', this._onItemCreate.bind(this));

    // Delete Inventory Item
    html.on('click', '.item-delete', (ev) => {
      const li = $(ev.currentTarget).parents('.item');
      const item = this.actor.items.get(li.data('itemId'));
      item.delete();
      li.slideUp(200, () => this.render(false));
    });

    // Active Effect management
    html.on('click', '.effect-control', (ev) => {
      const row = ev.currentTarget.closest('li');
      const document =
        row.dataset.parentId === this.actor.id
          ? this.actor
          : this.actor.items.get(row.dataset.parentId);
      onManageActiveEffect(ev, document);
    });

    // Rollable abilities.
    html.on('click', '.rollable', this._onRoll.bind(this));

    // Drag events for macros.
    if (this.actor.isOwner) {
      let handler = (ev) => this._onDragStart(ev);
      html.find('li.item').each((i, li) => {
        if (li.classList.contains('inventory-header')) return;
        li.setAttribute('draggable', true);
        li.addEventListener('dragstart', handler, false);
      });
    }
  }

  /**
   * Handle creating a new Owned Item for the actor using initial data defined in the HTML dataset
   * @param {Event} event   The originating click event
   * @private
   */
  async _onItemCreate(event) {
    event.preventDefault();
    const header = event.currentTarget;
    // Get the type of item to create.
    const type = header.dataset.type;
    // Grab any data associated with this control.
    const data = duplicate(header.dataset);
    // Initialize a default name.
    const name = `New ${type.capitalize()}`;
    // Prepare the item object.
    const itemData = {
      name: name,
      type: type,
      system: data,
    };
    // Remove the type from the dataset since it's in the itemData.type prop.
    delete itemData.system['type'];

    // Finally, create the item!
    return await Item.create(itemData, { parent: this.actor });
  }

  /**
   * Handle clickable rolls.
   * @param {Event} event   The originating click event
   * @private
   */
  _onRoll(event) {
    event.preventDefault();
    const element = event.currentTarget;
    const dataset = element.dataset;

    // Handle item rolls.
    if (dataset.rollType) {
      if (dataset.rollType == 'item') {
        const itemId = element.closest('.item').dataset.itemId;
        const item = this.actor.items.get(itemId);
        if (item) return item.roll();
      }
    }

    // Handle rolls that supply the formula directly.
    if (dataset.roll) {
      let label = dataset.label ? `[ability] ${dataset.label}` : '';
      let roll = new Roll(dataset.roll, this.actor.getRollData());
      roll.toMessage({
        speaker: ChatMessage.getSpeaker({ actor: this.actor }),
        flavor: label,
        rollMode: game.settings.get('core', 'rollMode'),
      });
      return roll;
    }
  }
}

const ItemSheet$1 = foundry.appv1.sheets.ItemSheet;

/**
 * Extend the basic ItemSheet with some very simple modifications
 * @extends {ItemSheet}
 */
class LotmItemSheet extends ItemSheet$1 {
  /** @override */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ['lotm', 'sheet', 'item'],
      width: 520,
      height: 480,
      tabs: [
        {
          navSelector: '.sheet-tabs',
          contentSelector: '.sheet-body',
          initial: 'description',
        },
      ],
    });
  }

  /** @override */
  get template() {
    const path = 'systems/lotm/templates/item';
    // Return a single sheet for all item types.
    // return `${path}/item-sheet.hbs`;

    // Alternatively, you could use the following return statement to do a
    // unique item sheet by type, like `weapon-sheet.hbs`.
    return `${path}/item-${this.item.type}-sheet.hbs`;
  }

  /* -------------------------------------------- */

  /** @override */
  async getData() {
    // Retrieve base data structure.
    const context = super.getData();

    // Use a safe clone of the item data for further operations.
    const itemData = this.document.toPlainObject();

    // Enrich description info for display
    // Enrichment turns text like `[[/r 1d20]]` into buttons
    context.enrichedDescription = await TextEditor.enrichHTML(
      this.item.system.description,
      {
        // Whether to show secret blocks in the finished html
        secrets: this.document.isOwner,
        // Necessary in v11, can be removed in v12
        async: true,
        // Data to fill in for inline rolls
        rollData: this.item.getRollData(),
        // Relative UUID resolution
        relativeTo: this.item,
      }
    );

    // Add the item's data to context.data for easier access, as well as flags.
    context.system = itemData.system;
    context.flags = itemData.flags;

    // Adding a pointer to CONFIG.LOTM
    context.config = CONFIG.LOTM;

    // Prepare active effects for easier access
    context.effects = prepareActiveEffectCategories(this.item.effects);

    return context;
  }

  /* -------------------------------------------- */

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    // Everything below here is only needed if the sheet is editable
    if (!this.isEditable) return;

    // Roll handlers, click handlers, etc. would go here.

    // Active Effect management
    html.on('click', '.effect-control', (ev) =>
      onManageActiveEffect(ev, this.item)
    );
  }
}

const { loadTemplates } = foundry.applications.handlebars;

/**
 * Define a set of template paths to pre-load
 * Pre-loaded templates are compiled and cached for fast access when rendering
 * @return {Promise}
 */
const preloadHandlebarsTemplates = async function () {
  return loadTemplates([
    // Actor partials.
    'systems/lotm/templates/actor/parts/actor-pathway.hbs',
    'systems/lotm/templates/actor/parts/actor-features.hbs',
    'systems/lotm/templates/actor/parts/actor-items.hbs',
    'systems/lotm/templates/actor/parts/actor-spells.hbs',
    'systems/lotm/templates/actor/parts/actor-effects.hbs',
    'systems/lotm/templates/actor/parts/actor-character.hbs',
    // Item partials
    'systems/lotm/templates/item/parts/item-effects.hbs',
  ]);
};

const lordOfMysteries = [
  { name: "Fool", key: "fool" },
  { name: "Error", key: "error" },
  { name: "Door", key: "door" }
];

const GodAlmighty = [
  { name: "Visionary", key: "visionary" },
  { name: "Sun", key: "sun" },
  { name: "Tyrant", key: "tyrant" },
  { name: "White Tower", key: "white-tower" },
  { name: "Hanged Man", key: "hanged-man" }
];

const EternalDarkness = [
  { name: "Darkness", key: "darkness" },
  { name: "Death", key: "death" },
  { name: "Twilight Giant", key: "twilight-giant" }
];

const CalamityOfDestruction = [
  { name: "Demoness", key: "demoness" },
  { name: "Red Priest", key: "red-priest" }
];

const DemonKnowledge = [
  { name: "Hermit", key: "hermit" },
  { name: "Paragon", key: "paragon" }
];

const KeyOfLight = [
  { name: "Wheel of Fortune", key: "wheel-of-fortune" }
];

const GoddesOfOrigin = [
  { name: "Mother", key: "mother" },
  { name: "Moon", key: "moon" }
];

const FatherOfDevils = [
  { name: "Abyss", key: "abyss" },
  { name: "Chained", key: "chained" }
];

const TheAnarchy = [
  { name: "Black Emperor", key: "black-emperor" },
  { name: "Justiciar", key: "justiciar" }
];

const pathways = [
  ...lordOfMysteries,
  ...CalamityOfDestruction,
  ...DemonKnowledge,
  ...EternalDarkness,
  ...FatherOfDevils,
  ...GodAlmighty,
  ...GoddesOfOrigin,
  ...KeyOfLight,
  ...TheAnarchy,
];

const sequences = [
  {name: "9", key: 9},
  {name: "8", key: 8},
  {name: "7", key: 7},
  {name: "6", key: 6},
  {name: "5", key: 5},
  {name: "4", key: 4},
  {name: "3", key: 3},
  {name: "2", key: 2},
  {name: "1", key: 1},
  {name: "0", key: 0}
];

const LOTM = {};
/**
 * The set of Ability Scores used within the system.
 * @type {Object}
 */
LOTM.abilities = {
  cha: 'LOTM.Ability.Cha.long',
  str: 'LOTM.Ability.Str.long',
  lck: 'LOTM.Ability.Lck.long',
  agi: 'LOTM.Ability.Agi.long',
  phy: 'LOTM.Ability.Phy.long',
  wll: 'LOTM.Ability.Wll.long',
  ins: 'LOTM.Ability.Ins.long',
  edu: 'LOTM.Ability.Edu.long'
};

LOTM.abilityAbbreviations = {
  cha: 'LOTM.Ability.Cha.abbr',
  str: 'LOTM.Ability.Str.abbr',
  lck: 'LOTM.Ability.Lck.abbr',
  agi: 'LOTM.Ability.Agi.abbr',
  phy: 'LOTM.Ability.Phy.abbr',
  wll: 'LOTM.Ability.Wll.abbr',
  ins: 'LOTM.Ability.Ins.abbr',
  edu: 'LOTM.Ability.Edu.abbr'
};

LOTM.pathways = pathways;
LOTM.sequences = sequences;

class LotmDataModel extends foundry.abstract.TypeDataModel {
  /**
   * Convert the schema to a plain object.
   * 
   * The built in `toObject()` method will ignore derived data when using Data Models.
   * This additional method will instead use the spread operator to return a simplified
   * version of the data.
   * 
   * @returns {object} Plain object either via deepClone or the spread operator.
   */
  toPlainObject() {
    return {...this};
  }
}

class LotmActorBase extends LotmDataModel {

  static defineSchema() {
    const { SchemaField, StringField, NumberField, BooleanField } = foundry.data.fields;
    const requiredInteger = { required: true, nullable: false, integer: true };
    const schema = {};

    schema.isBeyonder = new SchemaField({
      value: new BooleanField({initial: false})
    });

    schema.race = new SchemaField({
      value: new StringField({ required: true, blank: true })
    });
    schema.path = new SchemaField({
      value: new StringField({ required: true, blanck: true })
    });
    schema.gender = new StringField({ required: true, blank: true, readonly: false, initial: "", recursive: false });
    schema.biography = new StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.sequence = new SchemaField({
      value: new NumberField({ required: false, nullable: true, min: 0 }),
      max: new NumberField({ required: false, initial: 10 })
    });

    schema.age = new SchemaField({
      value: new NumberField({ ...requiredInteger, initial: 16, min: 16 }),
      max: new NumberField({ ...requiredInteger, initial: 99999 })
    });

    schema.health = new SchemaField({
      value: new NumberField({ ...requiredInteger, initial: 0, min: 0 }),
      extra: new NumberField({ ...requiredInteger, initial: 0 }),
      hit: new NumberField({ ...requiredInteger, initial: 0 }),
      init: new NumberField({ ...requiredInteger, initial: 10 })
    });
    schema.power = new SchemaField({
      value: new NumberField({ ...requiredInteger, initial: 5, min: 0 }),
      max: new NumberField({ ...requiredInteger, initial: 5 })
    });

    return schema;
  }

}

class LotmCharacter extends LotmActorBase {

  static defineSchema() {
    const fields = foundry.data.fields;
    const requiredInteger = { required: true, nullable: false, integer: true };
    const schema = super.defineSchema();
    schema.occupation = new fields.StringField({ initial: "" });
    schema.semiMyticCreatureMode = new fields.SchemaField({
      value: new fields.BooleanField({ initial: false })
    });
    schema.grade = new fields.SchemaField({
      value: new fields.StringField()
    });

    schema.max_points_abilities = new fields.NumberField({ initial: 32, min: 0 });
    schema.spirituality = new fields.NumberField({ initial: 0 });
    // Iterate over ability names and create a new SchemaField for each.
    schema.abilities = new fields.SchemaField(Object.keys(CONFIG.LOTM.abilities).reduce((obj, ability) => {
      obj[ability] = new fields.SchemaField({
        value: new fields.NumberField({ ...requiredInteger, initial: 0, min: 0, max: 6, step: 1 }),
        boost: new fields.SchemaField({
          value: new fields.NumberField({ initial: 0 })
        })
      });
      return obj;
    }, {}));

    return schema;
  }

  prepareDerivedData() {
    if (this.sequence.value === null) {
      this.grade.value = "Common Person";
    }
    if ([9, 8].includes(this.sequence.value)) {
      this.grade.value = "Low Sequence";
    }
    if ([7, 6, 5].includes(this.sequence.value)) {
      this.grade.value = "Mid Sequence";
    }
    if ([4, 3].includes(this.sequence.value)) {
      this.grade.value = "High Sequence - Saint";
    }
    if ([2, 1].includes(this.sequence.value)) {
      this.grade.value = "High Sequence - Angel";
    }
    if (this.sequence.value === 0) {
      this.grade.value = "True God";
    }

    // Loop through ability scores, and add their modifiers to our sheet output.
    for (const key in this.abilities) {
      // Calculate the modifier using d20 rules.
      this.abilities[key].mod = Math.floor((this.abilities[key].value - 10) / 2);
      // Handle ability label localization.
      this.abilities[key].label = game.i18n.localize(CONFIG.LOTM.abilities[key]) ?? key;
    }
    // (((((((10+'主体信息'!R7+
    let derivatedMaxHealth = this.health.init + this.abilities['phy'].value;
    console.log('init', derivatedMaxHealth);
    // IF(V2<=9,SUM(V18:W18),0)+
    // IF(V2<=8,SUM(V18:X18),0)+
    // IF(V2<=7,SUM(V18:Y18),0)+
    // IF(V2<=6,SUM(V18:Z18),0)+
    // IF(V2<=5,SUM(V18:AA18),0)+
    if (this.sequence.value <= 9 && this.sequence.value >= 5) {
      derivatedMaxHealth += this.abilities['phy'].value * ((9 - this.sequence.value) + 1) + this.abilities['phy'].boost.value;
    }
    // IF(V2<=4,SUM(V18:AB18)*2,0))
    if (this.sequence.value == 4) {
      derivatedMaxHealth += (this.abilities['phy'].value * (9 - this.sequence.value) + this.abilities['phy'].boost.value) * 2;
    }
    // *IF(V2<=4,2,1))+
    if (this.sequence.value <= 4) {
      derivatedMaxHealth = derivatedMaxHealth * 2;
    }
    // IF(V2<=3,SUM(V18:AC18)*2,0)+
    if (this.sequence.value == 3) {
      derivatedMaxHealth += (this.abilities['phy'].value * (9 - this.sequence.value) + this.abilities['phy'].boost.value) * 2;
    }
    // IF(V2<=2,SUM(V18:AD18)*3,0))*
    if (this.sequence.value == 2) {
      derivatedMaxHealth += (this.abilities['phy'].value + this.abilities['phy'].boost.value) * 3 + (9 - this.sequence.value);
    }
    //IF(V2<=2,2,1)+
    if (this.sequence.value <= 2) {
      derivatedMaxHealth = derivatedMaxHealth * 2;
    }
    // IF(V2<=1,SUM(V18:AE18)*3,0))*
    if (this.sequence.value == 1) {
      derivatedMaxHealth += ((this.abilities['phy'].value + this.abilities['phy'].boost.value) * 3) + (9 - this.sequence.value);
    }
    // IF(V3="天使之王",1.5
    // IF(V3="真神",1.5
    // IF(V3="旧日",1.5
    // V3="支柱",1.5 +
    if (["King of Angels", "True God", "Old One", "Pilar"].includes(this.grade.value)) ;
    //IF(V2=0,SUM(V18:AF18)*4,0))*
    if (this.sequence === 0) {
      derivatedMaxHealth += this.abilities['phy'].boost.value * 4;
    }

    // IF(V2=0,2,1))*
    if (this.sequence === 0) {
      derivatedMaxHealth = derivatedMaxHealth * 2;
    }

    // IF(V3="旧日",3,IF(V3="支柱",3,1)))*
    if (["Old One", "Pilar"].includes(this.grade.value)) {
      derivatedMaxHealth = derivatedMaxHealth * 3;
    }

    if (['Pilar'].includes(this.grade.value)) {
      derivatedMaxHealth = derivatedMaxHealth * 4;
    }


    // *IF(V3="支柱",4,1)+
    // SUM('主体信息'!AZ4:BA13)/5
    if (this.semiMyticCreatureMode.value === true) ;

    derivatedMaxHealth += this.health.extra;
    this.health.value = derivatedMaxHealth - this.health.hit;


    this.health.derivatedMax = derivatedMaxHealth;
  }

  getRollData() {
    const data = {};

    // Copy the ability scores to the top level, so that rolls can use
    // formulas like `@str.mod + 4`.
    if (this.abilities) {
      for (let [k, v] of Object.entries(this.abilities)) {
        data[k] = foundry.utils.deepClone(v);
      }
    }

    //data.lvl = this.attributes.level.value;

    return data
  }
}

class LotmNPC extends LotmActorBase {

  static defineSchema() {
    const fields = foundry.data.fields;
    const requiredInteger = { required: true, nullable: false, integer: true };
    const schema = super.defineSchema();

    schema.cr = new fields.NumberField({ ...requiredInteger, initial: 1, min: 0 });
    schema.xp = new fields.NumberField({ ...requiredInteger, initial: 0, min: 0 });
    
    return schema
  }

  prepareDerivedData() {
    this.xp = this.cr * this.cr * 100;
  }
}

class LotmItemBase extends LotmDataModel {

  static defineSchema() {
    const fields = foundry.data.fields;
    const schema = {};

    schema.description = new fields.StringField({ required: true, blank: true });

    return schema;
  }

}

class LotmItem extends LotmItemBase {

  static defineSchema() {
    const fields = foundry.data.fields;
    const requiredInteger = { required: true, nullable: false, integer: true };
    const schema = super.defineSchema();

    schema.quantity = new fields.NumberField({ ...requiredInteger, initial: 1, min: 1 });
    schema.weight = new fields.NumberField({ required: true, nullable: false, initial: 0, min: 0 });

    // Break down roll formula into three independent fields
    schema.roll = new fields.SchemaField({
      diceNum: new fields.NumberField({ ...requiredInteger, initial: 1, min: 1 }),
      diceSize: new fields.StringField({ initial: "d20" }),
      diceBonus: new fields.StringField({ initial: "+@str.mod+ceil(@lvl / 2)" })
    });

    schema.formula = new fields.StringField({ blank: true });

    return schema;
  }

  prepareDerivedData() {
    // Build the formula dynamically using string interpolation
    const roll = this.roll;

    this.formula = `${roll.diceNum}${roll.diceSize}${roll.diceBonus}`;
  }
}

class LotmFeature extends LotmItemBase {}

class LotmSpell extends LotmItemBase {

  static defineSchema() {
    const fields = foundry.data.fields;
    const schema = super.defineSchema();

    schema.spellLevel = new fields.NumberField({ required: true, nullable: false, integer: true, initial: 1, min: 1, max: 9 });

    return schema;
  }
}

/**
 * A class representing the Classless Skill Tree 5E module
 * @typedef {Object} ClasslessSkillTree5E
 * @property {string} ID the full ID, used e.g. for Foundry
 * @property {string} SHORT_ID the short ID, used e.g. for logging
 * @property {Object} FLAGS (needed for Foundry?)
 * @property {Object} TEMPLATES (needed for Foundry?)
 */
class ClasslessSkillTree5E {
  static ID = "classless-skill-tree-5e";
  static SHORT_ID = "CST5E";

  static FLAGS = {};

  static TEMPLATES = {};
}

/**
 * A class with utility functions that can be used anywhere
 */
class SkillTreeUtils {
    /**
     * Checks if an id is valid
     * @param {string} id the id you want to check the validity of.  \
     *      Uses the Regular Expression `/^[a-zA-Z][a-zA-Z\d]*([_\-][a-zA-Z\d]+)*$/`  \
     *      This means that the id must be alphanumeric, but may have dashes and underscores in the middle, one at a time.
     * @returns {boolean} true if this is a valid id, false if it is invalid.
     */
    static isValidId(id) {
        return id.match(/^[a-zA-Z][a-zA-Z\d]*([_\-][a-zA-Z\d]+)*$/).length > 0;
    }

    /**
     * Checks if a string is a HEX color code
     * @param {string} color The string you want to check whether or not it is a valid HEX-code for a color.  \
     *      Uses the Regular Expression `/^#[0-9A-F]{6}$/`
     * @returns {boolean} true if this is a valid HEX color code, false if it is invalid.
     */
    static isValidColor(color) {
        return color.match(/^#[\dA-F]{6}$/).length > 0;
    }

    /**
     * Output a log to the console with the package prefix if debug mode is on or force is true.
     * @param {boolean} force Whether to force output, or let Foundry Dev Mode setting decide.
     * @param  {...any} args The arguments you would otherwise give to console.log()
     */
    static log(force, ...args) {
        const shouldLog =
            force ||
            game.modules
                .get("_dev-mode")
                ?.api?.getPackageDebugValue(ClasslessSkillTree5E.ID);

        if (shouldLog) {
            console.log(`${ClasslessSkillTree5E.ID} | `, ...args);
        }
    }

    /**
     * Output a warning to the console with the package prefix if debug mode is on or force is true.
     * @param {boolean} force Whether to force output, or let Foundry Dev Mode setting decide.
     * @param  {...any} args The arguments you would otherwise give to console.warn()
     */
    static warn(force, ...args) {
        const shouldLog =
            force ||
            game.modules
                .get("_dev-mode")
                ?.api?.getPackageDebugValue(ClasslessSkillTree5E.ID);

        if (shouldLog) {
            console.warn(`${ClasslessSkillTree5E.ID} | `, ...args);
        }
    }
}

// Import document classes.

const Actors = foundry.documents.collections.Actors;
const ActorSheet = foundry.appv1.sheets.ActorSheet;
const Items = foundry.documents.collections.Items;
const ItemSheet = foundry.appv1.sheets.ItemSheet;


Hooks.once("devModeReady", ({ registerPackageDebugFlag }) => {
  SkillTreeUtils.log(false, "Dev Mode Ready");
  registerPackageDebugFlag(ClasslessSkillTree5E.ID);
});

/* -------------------------------------------- */
/*  Init Hook                                   */
/* -------------------------------------------- */

Hooks.once('init', function () {
  // Add utility classes to the global game object so that they're more easily
  // accessible in global contexts.
  SkillTreeUtils.log(false, "Main Initialized!");
  game.lotm = {
    LotmActor,
    LotmItem: LotmItem$1,
    rollItemMacro,
  };

  // Add custom constants for configuration.
  CONFIG.LOTM = LOTM;

  /**
   * Set an initiative formula for the system
   * @type {String}
   */
  CONFIG.Combat.initiative = {
    formula: '1d20 + @abilities.dex.mod',
    decimals: 2,
  };

  // Define custom Document and DataModel classes
  CONFIG.Actor.documentClass = LotmActor;

  // Note that you don't need to declare a DataModel
  // for the base actor/item classes - they are included
  // with the Character/NPC as part of super.defineSchema()
  CONFIG.Actor.dataModels = {
    character: LotmCharacter,
    npc: LotmNPC
  };
  CONFIG.Item.documentClass = LotmItem$1;
  CONFIG.Item.dataModels = {
    item: LotmItem,
    feature: LotmFeature,
    spell: LotmSpell
  };

  // Active Effects are never copied to the Actor,
  // but will still apply to the Actor from within the Item
  // if the transfer property on the Active Effect is true.
  CONFIG.ActiveEffect.legacyTransferral = false;

  // Register sheet application classes
  Actors.unregisterSheet('core', ActorSheet);
  Actors.registerSheet('lotm', LotmActorSheet, {
    makeDefault: true,
    label: 'LOTM.SheetLabels.Actor',
  });
  Items.unregisterSheet('core', ItemSheet);
  Items.registerSheet('lotm', LotmItemSheet, {
    makeDefault: true,
    label: 'LOTM.SheetLabels.Item',
  });

  // Preload Handlebars templates.
  return preloadHandlebarsTemplates();
});

/* -------------------------------------------- */
/*  Handlebars Helpers                          */
/* -------------------------------------------- */

// If you need to add Handlebars helpers, here is a useful example:
Handlebars.registerHelper('toLowerCase', function (str) {
  return str.toLowerCase();
});

/* -------------------------------------------- */
/*  Ready Hook                                  */
/* -------------------------------------------- */

Hooks.once('ready', function () {
  // Wait to register hotbar drop hook on ready so that modules could register earlier if they want to
  Hooks.on('hotbarDrop', (bar, data, slot) => createItemMacro(data, slot));
  // setupSkillTree()
});

/* -------------------------------------------- */
/*  Hotbar Macros                               */
/* -------------------------------------------- */

/**
 * Create a Macro from an Item drop.
 * Get an existing item macro if one exists, otherwise create a new one.
 * @param {Object} data     The dropped data
 * @param {number} slot     The hotbar slot to use
 * @returns {Promise}
 */
async function createItemMacro(data, slot) {
  // First, determine if this is a valid owned item.
  if (data.type !== 'Item') return;
  if (!data.uuid.includes('Actor.') && !data.uuid.includes('Token.')) {
    return ui.notifications.warn(
      'You can only create macro buttons for owned Items'
    );
  }
  // If it is, retrieve it based on the uuid.
  const item = await Item.fromDropData(data);

  // Create the macro command using the uuid.
  const command = `game.lotm.rollItemMacro("${data.uuid}");`;
  let macro = game.macros.find(
    (m) => m.name === item.name && m.command === command
  );
  if (!macro) {
    macro = await Macro.create({
      name: item.name,
      type: 'script',
      img: item.img,
      command: command,
      flags: { 'lotm.itemMacro': true },
    });
  }
  game.user.assignHotbarMacro(macro, slot);
  return false;
}

/**
 * Create a Macro from an Item drop.
 * Get an existing item macro if one exists, otherwise create a new one.
 * @param {string} itemUuid
 */
function rollItemMacro(itemUuid) {
  // Reconstruct the drop data so that we can load the item.
  const dropData = {
    type: 'Item',
    uuid: itemUuid,
  };
  // Load the item from the uuid.
  Item.fromDropData(dropData).then((item) => {
    // Determine if the item loaded and if it's an owned item.
    if (!item || !item.parent) {
      const itemName = item?.name ?? itemUuid;
      return ui.notifications.warn(
        `Could not find item ${itemName}. You may need to delete and recreate this macro.`
      );
    }

    // Trigger the item roll
    item.roll();
  });
}
